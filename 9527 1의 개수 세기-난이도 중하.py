#중하인 이유: 규칙찾기가 쉽고 명백함
N,M=map(int,input().split())
def func(N):
    rst=0
    cnt=1#1의자리 1의 개수
    while cnt<=N:
        mok=N//(cnt*2)#한 세트 
        rest=N%(cnt*2)#세트하고 남은거 
        k=mok*cnt+max(0,rest-cnt+1)
        rst+=mok*cnt
        rst+=max(0,rest-cnt+1)
        
        cnt*=2
    return rst

print(func(M)-func(N-1))

#0부터 숫자를 셀 때 1의 자리수는 0101010101이 된다. 따라서 2의 배수만큼끊으면 반은 1이다.
#2의 자리수는 001100110011....이 된다. 따라서 4의 배수만큼 끊으면 반은 1이다.
#4의 자리수는............... 따라서 8의 배수만큼 끊으면 반은 1이다.
#이를 이용하면 시간은 대략 로그만큼 될 것임을 알 수 있다.
#그럼 배수이후는???
#n의 자리수는 n에서 처음으로 1이나오고 그 때를 포함하여 n번 1이 나온다.
#따라서 2n으로 나눈 나머지에서 n을 빼고 +1해준 값만큼 1이 나온다.
#물론 이 값이 음수이면 그냥 0이되어야하므로 0과 rest-cnt+1 중에서 max값을 준다.
#