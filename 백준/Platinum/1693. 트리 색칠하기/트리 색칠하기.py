import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)
'''
기본적으로는
1부터 시작해서 자식들이 갖고 있지 않은 색을 자신의 색으로 준다.
만약 이 숫자를 더 당길 수 있는지 확인해보면 어떻게 해야할까?
i번 색을 가진 자식노드를 변경시켜야한다.
자식 트리에서 최대 노드 색이 k라면
부모를 1~k+1로 변형시켜야한다.
이 때의 비용을 갖고 있어야 한다.

기본적으로 각 트리는 자신의 최소비용을 유지하고 있다
따라서 루트노드를 더 작은 번호로 할당하는 것은 트리 내부에서의 비용이 발생한다.
당기는 것이 이득을 볼 수도 있긴 하겠네..




모든 트리에서 최소 비용과 그 다음 비용을 가지고 있다면?
(대신 루트는 서로 달라야한다.)
그렇다면 이야기는 쉽지?

대신 두번째 색의 루트에 대해서 어떻게 구하지?

리프라면 무조건 베스트는 1, 세컨드는 2이다.


그럼 현재 k번인 루트노드를 i번 색으로 바꾸려면
sum( 2nd_i - 1st_i for i in my_son if color[son] == i)만큼의 비용이 들고
k-i만큼이 회수가 일어난다.
최종 적으로 sum -k +i 만큼의 비용을 들이면 i번 색으로 바꿀 수 있다.


대신 이 방법은 루트마다 즉 모든 노드마다 모든 색을 탐색해야한다.
하지만 10만개의 색을 가지는 경우는 사실 없다.
10만개의 색을 가지려면 하나의 노드 밑에 99999개의 자식이 있어야하는데
그런 경우에는 99999개의 노드가 전부 1번 색이 되기 때문이다.

각 색깔 개수 별 최소 노드의 하계를 잡아보자.
즉 i개 색으로 n개의 노드로 이루어진 트리는 무조건 커버할 수 있다! 하는 n을 찾아보자.
당연한 예시로, 4개의 색은 4개의 노드로 이루어진 트리를 커버할 수 있다.

1번 색 : 1개의 노드
2번 색 : 1개의 1색 자식 노드 -> 2개
3번 색 : 1개의 1색 자식노드, 1개의 2색 자식노드 -> 4개
4번 색 : 8개
-> n개의 색은 2^n개의 트리는 거뜬히 커버할 수 있다.
-> 노드는 최대 10만개이므로 17개의 색만 체크하면 된다.
-> 위의 계산은 러프하므로 당연히 더 많은 노드를 커버할 수 있다. ex) 4노드 트리는 사실 2색으로 가능 


그럼 시간 복잡도는 nlogn으로 처리가 될 것이다.

탐색 방법은 어떻게 하지?
베이스는 DFS인데 재귀로 할까 반복문으로 할까?
-> 코드 설명은 친절?하니까 코드 작성은 불친절!하게 반복문으로 해보자.
유사 dfs를 할 것인가 정석 dfs를 할 것인가?
-> 자식노드 처리 완료 후 부모노드로 돌아올 필요가 있으므로 stk에서 pop하는 dfs는 곤란하다.

그렇다면 모든 인접노드의 처리가 완료되었는지는 어떻게 확인할 것인가?
-> dfs 한 번으로 문제 풀이를 완료하고, 재탐색을 하지 않을 것이므로 adj에서 pop을 하자.
-> 트리를 구축(부모 자식 관계 설정)하는 동시에 문제를 풀면 될 것 같다.
-> NO...NO.... 

스택 내에서 포인터는 필요한가?
-> 강한연결요소과는 다르게 스택에 남겨둔 채로 다른 자식 노드로 이동하는 경우는 없을 것 같다.


로직 요약
최소비용 서브트리의 루트 색과 변경비용을 저장한다.
리프의 경우는 [1,1]이 된다.
i번을 루트로 하려고 하면 자식 노드 전체 비용의 합계 + i + 루트가 i인 자식 트리 변경 비용 합계가 된다.
이 중에서 가장 작은 것과 그 다음 것을 저장하면 된다.
'''
MAX = 1<<17

N = int(input())
adj = [ [] for _ in range(N+1)]
visited = [0]*(N+1) # 여기에 바로 info를 덮어쓰자.
                     # info[i] = (1st_min, 2nd_min)
for _ in range(N-1):
    a,b = map(int,input().split())
    adj[a].append(b)
    adj[b].append(a)



def dfs(cur):
    visited[cur] = 1
    rst=0
    C = [ [i,i] for i in range(18)] # val, col
    for nxt in adj[cur]:
        if visited[nxt] : continue
        color, val, add = dfs(nxt)
        C[color][0] += add
        rst += val
    C.sort()

    diff = C[2][0]-C[1][0]
    root_color = C[1][1]
    min1 = rst+C[1][0]
    return root_color, min1, diff
    

print(dfs(1)[1])
