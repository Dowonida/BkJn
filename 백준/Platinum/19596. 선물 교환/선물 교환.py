import sys
input = sys.stdin.readline

'''
양방향 간선이 주어지고, 각 점에 대한 인/아웃풋 개수가 비슷해야하는 문제
들어왔으면 나가야한다는 점에서 한붓그리기를 연상시킴
모든 점에 간선이 짝수개씩 있다고 가정해보자.
그럼 각각의 연결그래프에 대해서 모두 한붓그리기가 가능해지고
한붓그리기가 성공한다면 모든 점에는 인풋=아웃풋이 되므로
인풋-아웃풋 = 0이 된다.

이번에는 홀수 점이 있는 그래프를 생각해보자.
홀수 점의 개수는 반드시 짝수개이다.
우선 홀수 점에서 그래프를 출발시켰다고 생각해보자.
그럼 반드시 '다른' 홀수점에서 경로는 끝이 난다.
경로 탐색이 끝난 다음의 결과를 생각해보면 다음과 같은 점을 알 수 있다.
1. 시작점은 짝수개의 간선이 남아있다.
2. 중간점은 짝수개의 간선이 줄어들었다.
3. 종료점은 남은 간선이 없다. (있다면 다음 경로를 계속 가니까)


플랜
점들 중에서, 홀수 점을 찾은 다음, 거기서부터 도는 플랜
그런데 시작점은 간선이 한번에 다 처리되지 않을 수도 있다
ex) 12, 23, 34, 41, 15에서 15를 먼저 처리한 경우
그럼 한번 고른 시작점이 간선을 다 쓸 때까지 돌리는 방법도 있다.
ex) 15, 12-23-34-41
하지만 12, 13, 14같은 경우 위의 방법으로 진행하면
1의 아웃풋만 3, 인풋은 0으로 조건을 불만족하게 된다.
그렇다면 홀짝마다 인아웃풋을 바꿔보면?

1번째 탐색: 1에서출발, 12
2번째 탐색: 1에서 역방향출발 31
3번째 탐색: 1에서 정방향출발 14

그런데 이렇게하면 점의 홀짝을 따질 필요도 없을것 같다.
왜냐면 짝수점에서 출발해서 간선이 남았더라도 시작점 입장에서
1회차 후에 남았다=다른점에서끝났다=홀수점이 되었다=인풋이 1많다
따라서 같은 시작점에서 역방향 탐색을 해주면 된다.

결론
로직은 다음과 같다.
1번 점부터 차례대로 n번점까지 반복문
각 점을 시작으로 dfs를 진행
홀짝을 따져서 순방향/역방향을 정함

우려되는 부분
1번 점을 진행하면서 k번 점을 방문하고
2번 점이나 k번 점을 시작점으로 두는 경우 문제가 생길 수 있나?

1번 점을 진행하면서 k번 점을 방문했을 때
k번 점의 간선을 모두 진행했다면 2번이나 k번시작에서 k번을 지나지 않음
k번 점의 간선이 남았다면 지나갔다는 뜻이므로 인풋=아웃풋인 상황임

'''

for _ in range(int(input())):
    N, M = map(int,input().split())
    #간선의 값 리스트
    #간선에 대한 visited 역할도 같이 한다.
    rst = [None]*M
    edges = []

    #간선 리스트
    #adj[3] = [ [1,3,0], [4,3,1], [3,2,6]]같은 식으로 저장?
    #그냥 간선 따로 저장하고 인덱스만 저장하자.
    adj = [ [] for _ in range(N+1)]
    for idx in range(M):
        a,b = map(int,input().split())
        edges.append((a,b))
        adj[a].append(idx)
        adj[b].append(idx)

    for start in range(1,N+1):
        parity = 1
        while adj[start]:
            parity = 1-parity

            cur = start #현재점
            while adj[cur]:
                edge_idx = adj[cur].pop()
                if rst[edge_idx] != None:
                    continue
                edge = edges[edge_idx]
                #parity가 0인경우 cur->nxt이므로 edge[0]=cur이면 0을 준다.
                #parity가 1인경우 방문순서는 cur->nxt이지만
                #실제로 간선은 nxt->cur이므로 edge[1]=cur이면 0을 준다.
                #즉 edge[parity] = cur이면 0 아니면 1
                if edge[parity] == cur:
                    rst[edge_idx] = '0'
                    cur = edge[1-parity]
                else:
                    rst[edge_idx] = '1'
                    cur = edge[parity]
    print(''.join(rst))
