#다른 피보나치 문제에서 F(n)이 F(0), F(1)을 몇 번 호출하냐는 문제가 있었다.
#그 때의 답은 F(0)이 F(n-2)번, F(1)이 F(n-1)번 호출된다는 것이었다.
#이를 바탕으로 생각해보았더니
#F(n)은 F(n-k)가 F(k)번, F(n-k-1)이 F(k-1)만큼 있다는 사실을 알게 되었다.
#F(0)과 F(1)의 값을 다르게 주어도 F(0)과 F(1)의 호출 개수는 변하지 않으며
#따라서 F(k)를 F(0)처럼 취급하고 거기서부터 피보나치수열을 전개한다고
#생각해보면 자연스럽게 유도가 된다.
#이를 이용하면 이 문제를 쉽게 풀 수 있을 것 같았다.
#N>K라고 하면 F(N)=F(K)*F(N-K)+F(K-1)*F(N-K-1)이 된다.
#그럼 gcd(F(N),F(K))는 gcd(F(K)*F(N-K)+F(k-1)*F(N-K-1))이 되고
#이는 gcd(F(K), F(K-1)*F(N-K-1))과 같아진다.
#그런데 gcd(F(K),F(K-1))=1이므로 위의 값은 gcd(F(K),F(N-K-1))이 된다.
#그럼 이를 점화적으로 반복하여 결과를 구할 수 있다.
#16과 24를 예로 들어보자.
#주어진 문제에서는 f(0)을 0으로 시작하므로 번호가 하나씩 당겨줘야한다.
#따라서 15와 23의 최대공약수를 구해보자.
#f(23)=f(15)f(8)+f(14)f(7)
#f(15)=f(7)f(8)+f(6)f(7)
#따라서 f(7)이 gcd

#ab+cd구조에서 a는 자기자신이고, b는 무엇이든 우변의 a나머지를  유지시켜주고
#c는 항상 서로소이므로 d만 보면 된다.

#그런데 N이 엄청크고 K가 작으면 엄청 많은 반복이 생길듯
#이를 한번에 해결은 불가능?
#어차피 F(K)보다 큰 공약수는 안생기니까
#주르륵 다 내리면 되겠네
#그럼 K의 배수를 다빼고 -1하자
#그럼 나머지-1이네
#그런데 그러면 잘 멈추나? F(7), F(7)을 만들고 싶은건데
#아 진행하면 그냥 7이 아니라 0으로 가네 오케이 그럼 K가 있는 동안
#그럼 그냥 gcd랑 비슷하겠네

dic={0:[1,0,0,1], 1:[1,1,1,0]}
def matp(A,B):
    return [(A[0]*B[0]+A[1]*B[2])%1000000007,(A[0]*B[1]+A[1]*B[3])%1000000007,
            (A[2]*B[0]+A[3]*B[2])%1000000007,(A[2]*B[1]+A[3]*B[3])%1000000007]

N,K=map(int,input().split())
N, K= max(N,K), min(N,K)
#N-=1
#K-=1
while K:
    N, K= K, N%K
N-=1
cnt=1
A=dic[1]
while cnt<=N:
    dic[cnt]=A
    A=matp(A,A)
    cnt<<=1

rst=dic[0]
cnt=1
while cnt<=N:
    if cnt&N:
        rst=matp(rst,dic[cnt])
    cnt<<=1
print(rst[0])
